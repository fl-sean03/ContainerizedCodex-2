import json
import subprocess
from pathlib import Path
from typing import Optional

from sqlalchemy.orm import Session

from app.core.config import settings
from app.core.logging import logger
from app.db import models


def write_job_request(workspace: Path, job: models.Job) -> Path:
    codex_dir = workspace / ".codex"
    codex_dir.mkdir(exist_ok=True)
    request_path = codex_dir / "request.json"

    payload = {
        "project_id": job.project_id,
        "job_id": job.id,
        "job_type": job.job_type,
        "instruction": job.instruction,
    }

    request_path.write_text(json.dumps(payload, indent=2), encoding="utf-8")
    return request_path


def dummy_worker_generate_snake_game(workspace: Path, job: models.Job) -> Path:
    """
    Fallback worker that just copies a static snake-game template
    for the initial_project job type. This is for smoke testing.
    """

    # Generate a minimal Python CLI project (file-based, easy to validate without a browser)
    readme_path = workspace / "README.md"
    app_path = workspace / "app.py"
    tests_dir = workspace / "tests"
    tests_dir.mkdir(exist_ok=True)
    test_path = tests_dir / "test_cli.py"

    readme_contents = (
        "# Python CLI — Fibonacci Example\n\n"
        "This project was generated by the dummy worker.\n\n"
        "Contents:\n"
        "- app.py: simple CLI that prints the first 10 Fibonacci numbers\n"
        "- tests/test_cli.py: a minimal test for fibonacci()\n"
        "- .codex/{request.json,result.json}\n\n"
        "Run:\n"
        "  python app.py\n"
    )

    app_contents = (
        "def fibonacci(n: int) -> list[int]:\n"
        "    \"\"\"Return the first n Fibonacci numbers as a list.\"\"\"\n"
        "    if n <= 0:\n"
        "        return []\n"
        "    seq = [0, 1]\n"
        "    while len(seq) < n:\n"
        "        seq.append(seq[-1] + seq[-2])\n"
        "    return seq[:n]\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    nums = fibonacci(10)\n"
        "    print(\",\".join(map(str, nums)))\n"
    )

    test_contents = (
        "from app import fibonacci\n"
        "\n"
        "def test_fibonacci_basic():\n"
        "    seq = fibonacci(10)\n"
        "    assert len(seq) == 10\n"
        "    assert seq[-1] == 34\n"
    )

    readme_path.write_text(readme_contents, encoding="utf-8")
    app_path.write_text(app_contents, encoding="utf-8")
    test_path.write_text(test_contents, encoding="utf-8")

    result = {
        "status": "success",
        "summary": "Dummy worker: created Python CLI Fibonacci example.",
        "created_files": ["README.md", "app.py", "tests/test_cli.py"],
        "modified_files": [],
        "errors": [],
        "logs": ["Dummy worker used instead of Codex."],
    }

    result_path = workspace / ".codex" / "result.json"
    result_path.write_text(json.dumps(result, indent=2), encoding="utf-8")
    return result_path


def run_codex_job(db: Session, project: models.Project, job: models.Job) -> Optional[Path]:
    """
    Entry point orchestrator uses to run a job.
    - Writes .codex/request.json
    - Either runs dummy worker or real Codex worker
    - Returns path to .codex/result.json (if exists)
    """

    workspace = Path(project.workspace_path)
    write_job_request(workspace, job)

    if settings.USE_DUMMY_WORKER:
        logger.info("Using dummy worker for job %s", job.id)
        result_path = dummy_worker_generate_snake_game(workspace, job)
        job.status = "completed"
        job.result_path = str(result_path)
        db.add(job)
        db.commit()
        db.refresh(job)
        return result_path

    # TODO: implement real Codex worker invocation, e.g.:
    #
    # docker run \\
    #   -v {workspace}:/workspace \\
    #   {settings.CODEX_WORKER_IMAGE} \\
    #   python /app/run_codex_job.py
    #
    # You can use subprocess or docker SDK here.

    try:
        # Use --volumes-from to share the backend's bind-mounted workspaces into the worker.
        # IMPORTANT: Pass the CONTAINER path, not host path, for WORKSPACE_DIR.
        # Backend mounts host ./backend/workspaces → container:/app/workspaces.
        # Therefore worker must use /app/workspaces/{project.id}
        container_ws = f"/app/workspaces/{project.id}"
        cmd = [
            "docker",
            "run",
            "--rm",
            "--volumes-from",
            "codex-backend",
            "-e", "OPENAI_API_KEY",
            "-e", "OPENAI_ORG_ID",
            "-e", "OPENAI_PROJECT",
            "-e", f"WORKSPACE_DIR={container_ws}",
            settings.CODEX_WORKER_IMAGE,
        ]
        logger.info("Running Codex worker: %s (WORKSPACE_DIR=%s)", " ".join(cmd), container_ws)
        subprocess.run(cmd, check=True)

        result_path = workspace / ".codex" / "result.json"
        if result_path.exists():
            job.status = "completed"
            job.result_path = str(result_path)
        else:
            job.status = "error"
        db.add(job)
        db.commit()
        db.refresh(job)
        return result_path if result_path.exists() else None

    except subprocess.CalledProcessError as exc:
        logger.error("Codex worker failed for job %s: %s", job.id, exc)
        job.status = "error"
        db.add(job)
        db.commit()
        db.refresh(job)
        return None
